#include <iostream>
#include <queue>
#include <cstdlib>
#include <limits>

#define INF std::numeric_limits<int>::max() / 2

int vCount, eCount, *dist;
std::vector< std::vector< std::pair<int,int> > > adj;
bool *isVisited;

void alloc() {
    dist = (int*) malloc((vCount + 1) * sizeof(int));
    isVisited = (bool*) malloc((vCount + 1) * sizeof(bool));
    adj.resize(vCount + 1);
}

void readInput() {
    int end1, end2, weight;
    std::cin >> vCount >> eCount;
    alloc();
    for(int i = 0; i < eCount; i++) {
        std::cin >> end1 >> end2 >> weight;
        adj[end1].push_back(std::make_pair(end2, weight));
    }
}

int lowestDistV() {
    int minDist = ((INF) + 1), minDistV;
    for(int i = 1; i <= vCount; i++) {
        if(dist[i] < minDist && !isVisited[i]) {
            minDist = dist[i];
            minDistV = i;
        }
    }
    return minDistV;
}

int dijkstra(int s, int t){
    for(int i = 1; i <= vCount; i++) {
        dist[i] = INF;
        isVisited[i] = false;
    }
    dist[s] = 0;
    int u;
    for(int i = 0; i < vCount; i++) {
        u = lowestDistV();
        isVisited[u] = true;
        if(u == t) break;
        for(int j = 0; j < (int)adj[u].size(); j++) {
            int v = adj[u][j].first;
            int w = adj[u][j].second;
            if(dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
            }
        }
    }
    return dist[t];
}

void processQuery() {
    int nQueries, source, target, result;
    std::cin >> nQueries;
    for(int i = 0; i < nQueries; i++) {
        std::cin >> source >> target;
        result = dijkstra(source, target);
        if(result == INF) std::cout <<  "Impossible!" << std::endl;
        else std::cout << result << std::endl;
    }
}

int main() {
	readInput();
    processQuery();
	free(isVisited);
	free(dist);
	return 0;
}
