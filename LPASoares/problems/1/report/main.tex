\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[top=20mm, bottom=20mm, left=22mm, right=20mm]{geometry}
\usepackage{tabularx}
\usepackage{lmodern}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{titlesec}
\usepackage{hyperref}

\usepackage{amsmath}
\usepackage{amsfonts}

\usepackage{algorithm,caption}
\usepackage[noend]{algpseudocode}

\usepackage{titling}

\setlength{\droptitle}{-5em}   

\usepackage{etoolbox}

\makeatletter
\newcommand*{\algrule}[1][\algorithmicindent]{
  \makebox[#1][l]{
    \hspace*{.1em}
    \vrule height .75\baselineskip depth .25\baselineskip
  }
}

\newcount\ALG@printindent@tempcnta
\def\ALG@printindent{
    \ifnum \theALG@nested>0
    \ifx\ALG@text\ALG@x@notext
    \else
    \unskip
    \ALG@printindent@tempcnta=1
    \loop
    \algrule[\csname ALG@ind@\the\ALG@printindent@tempcnta\endcsname]
    \advance \ALG@printindent@tempcnta 1
    \ifnum \ALG@printindent@tempcnta<\numexpr\theALG@nested+1\relax
    \repeat
    \fi
    \fi
}

\patchcmd{\ALG@doentity}{\noindent\hskip\ALG@tlm}{\ALG@printindent}{}{\errmessage{failed to patch}}
\patchcmd{\ALG@doentity}{\item[]\nointerlineskip}{}{}{} 
\makeatother

\titleformat{\section}{\normalfont\fontsize{12}{15}\bfseries}{\thesection}{0em}{}

\renewcommand{\baselinestretch}{1.35}

\title{%
  Report \\
  \Large LPA - Programming problem \#1 \\
  \large Team - Passevite}

\date{\vspace{-5ex}}

\begin{document}

\maketitle

\section*{Algorithm description}\label{algorithmDesc}
\begin{algorithm} \small
    \caption*{\footnotesize Optimize the positioning of vertices in $\mathbb{R}^2$ points in order to minimize the number of intersections between edges}\label{alg:optimizeIntersections}
    \begin{algorithmic}[1] \small
        \Procedure{optimize\_intersections}{$vertex$, $lastVertexPosition$}
        \If{$vertex$ has no edges} \Comment{Recursive step if $\neg$ last $vertex$}
            \If{$vertex$ $\neg$ last one} \Return \Call{optimize\_intersections}{$vertex, lastVertexPosition$}
            \Else 
            \State bestSolution $\gets$ temporarySolution \Comment{Base case, being the last $vertex$}
            \State \Return 1 if a solution with no intersections was found, 0 otherwise
            \EndIf
        \EndIf
        \For{$\forall$ \ $\mathbb{R}^2$ points $\in$ pointSet}
            \If{$\mathbb{R}^2$ point is free}
                \State $\mathbb{R}^2$ point $\gets$ Occupied
                \For{$\forall$ \ edges $\in$ $vertex$}
                    \For{$\forall$ \ edges $\in$ (temporarySolution $\setminus$ edges $\in$ $vertex$)}.
                        \If{edges intersect}
                            \State Update counter for edge crossings
                            \If{edge crossing count$\geq$ bestSolution} \Comment{Rejection Condition}
                            \State Free the point being used and get the next one (\textbf{goto} line 7) 
                            \EndIf
                        \EndIf
                    \EndFor
                    \State Add $vertex$ edge to temporarySolution
                \EndFor
                \State Add $vertex$ to temporarySolution
                \If{$vertex$ $\neg$ last one} \Comment{Recursive step if $\neg$ last $vertex$}
                    \If{\Call{optimize\_intersections}{$vertex, lastVertexPosition$} \tiny$=$ \small 1} 
                        \Return 1
                    \EndIf
                \Else 
                    \State bestSolution $\gets$ temporarySolution \Comment{Base case, being the last $vertex$}
                    \If{number of intersections in temporarySolution $=$ 0}
                        \Return 1
                    \EndIf
                \EndIf
            \EndIf
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
\qquad In order to improve the performance of our approach, and to avoid the massive repetition of edges intersection calculations, before starting to check for the optimal placement of the vertices on the $\mathbb{R}^2$ points given in the input, we've created an \verb|array| to store information about all possible intersections between 2 segments made by 4 vertices which are set in any of the $\mathbb{R}^2$ points available . Another trick to optimize our solution was to store the information on the vertex with the higher ID, while reading the input information regarding the edges (colliders). This way, when we're assigning a vertex to a given $\mathbb{R}^2$ point, we guarantee that all the other vertices needed to complete their edges were already previously set.

\section*{Intersection procedure}\label{intersectPorc}

\qquad Our approach to detecting the intersection of colliders is based on the concept of the orientation of an ordered triplet of points in the plane. Consider that A and B are the two colliders we are detecting an intersection for, and that A.1 is the source device for A, and A.2 is the target device for A (the same goes for B). The principle of this approach is that two colliders intersect if and only if one of the following conditions is verified:
\begin{itemize}
    \itemsep0em
    \item The orientations of the triplet (A.1, A.2, B.1) and the triplet (A.1, A.2, B.2) are different;
    \item The orientations of the triplet (B.1, B.2, A.1) and the triplet (B.1, B.2, A.2) are different;
    \item The two segments are collinear, and either their x-projections or y-projections intersect;
\end{itemize}

The orientation of a triplet of points can be clockwise, counter clockwise or collinear. To determine the orientation of a triplet of ordered points (A, B, C), we consider the segments AB and BC, then, we compute the slopes of these two segments, and compare them:

\begin{itemize}
    \itemsep0em
    \item If slope$_{AB}$ < slope$_{BC}$, then the triplet (A, B, C) is counter clockwise orientated
    \item If slope$_{AB}$ > slope$_{BC}$, then the triplet (A, B, C) is clockwise orientated
    \item If slope$_{AB}$ = slope$_{BC}$, then the triplet (A, B, C) is collinear
\end{itemize}

\section*{Data structures}\label{dataStruct}

\qquad For storing information about a point in the plane, we have the \verb|struct| $point_2d$, that has fields for the coordinates $x$ and $y$ \verb|int|, and also a \verb|boolean| $occupied$, which describes if any device is occupying that specific point in the plane at each moment. 
The \verb|struct| $edge$ represents one collider, and has fields $a$ and $b$, which are integers referring to the ID of the source and target devices for that collider.
The \verb|struct| $vertex$ refers to one device in the problem, and saves an \verb|array| of the IDs of all its neighbours (this is, the other devices that are connected to this device by a collider) - field $edge$ (as by the assignment we knew that at most there could be 28 edges, this \verb|array| is allocated with a size of 28 \verb|int|s); the number of neighbours of this vertex ($edge\_count$); and the boolean $seen$, where being "seen" means that this vertex is either the start or the end of an edge.
The \verb|struct| $solution$ is where we save the vertices location, the edges and the number of collisions found. This structure is employed several times throughout the program. Each time we finish placing all the edges on the plane, and meet a solution where the number of intersections is lower than the best one found until that moment, we copy the current solution to a variable $best_solution$. The variable $temp_solution$ is used for "building" a solution, that is, for registering which device is placed on which point of the room, and the number of intersections for that arrangement. The global variables of the problem are an array of 81 \verb|structs| $point_2d$, $points$, an array of 81 \verb|structs| $vertex$, $vertices$, an \verb|array| for storing the pre-processed intersections, $intersect$, the two \verb|structs| $solution$, $best_solution$ and $temp_solution$, and some auxiliary variables, such as the number of points in the plane, the number of devices to be placed and the number of colliders.

\section*{Correctness}

\qquad Our algorithm returns the lowest number of intersections between edges of a given graph $G=\{V,E\}$, after positioning all its vertices on $\mathbb{R}^2$ points of a given set $P=\{(x1,y1),(x2,y2),...,(xi,yi)\}$.\newline
\textbf{Base\ case}:
\begin{itemize}
    \itemsep0em
    \item Having all vertices with edges assigned a point $p \in P$
    \item Having an edges intersection count bigger that the best one we have so far $EI' > EI$
\end{itemize}
\textbf{Inductive\ hypotesis}: Assume we are putting vertex $i$, and currently number of intersections is $EI$ (before we assign our vertex), the number of intersections after positioning the vertex is $EI'$ and  and the best solution so far has $bEI$.
By \textbf{contradiction}, we assume that after positioning vertex $i$ there is some other solution $eBEI$ that is better than $EI'$. In this case we wold have that for $eBEI$ < $EI'$, then, $EI'$ < $EI$. Then we have a \textbf{contradiction} of our assumption, wich stated that befor putting the vertex we had $EI$ intersections, and the condition $EI \leq EI'$ is always true.

\section*{Algorithm Analysis}

\qquad Regarding memory complexity, we globally allocate all the data structures needed to support our algorithm to the higher bounds of the assignment and in total we have $\approx$ 41,2\verb|MB|. Since all the support information is already stored, the recursive function only allocates a total of 4 variables and use 2 input parameters to the function, hence we can say that our approach has a memory complexity of $\mathcal{O}(n)$.

In terms of time complexity, our algorithm follows a design pattern of subtract and conquer, which means that in each recursive call will have a subproblem of size \verb|n - 1|. Having such design, we can calculate its time complexity using the Muster Theorem\cite{textbook3}.
Let $T(n)$ be a function defined on positive values of $n$, and having the property:
\begin{equation*}
	T(n) \leq \left\{
	\begin{array}{rl}
		c & \text{if } n \leq 1,\\
		aT(n-b)+f(n) & \text{if } n > 1,
	\end{array} 
\right.\end{equation*}
for some constants $c$, $a > $ 0, $b >$ 0, $d\geq$ 0, and function $f(n)$. If $f(n)$ is in $O(n^d)$, then:
\begin{equation*}
	T(n)\ is\ in \left \{
	\begin{array}{ll}
		\mathcal{O}(n^d) & \text{if } a < 1,\\
		\mathcal{O}(n\textsuperscript{$d+1$}) & \text{if } a = 1,\\
		\mathcal{O}(n^da\textsuperscript{$n/b$}) & \text{if } a > 1,\\
	\end{array} 
\right.\end{equation*}
In our case, the number of subproblems is $|P|$, so $a = |P|$, since in each recursion we make one new call to the recursive function per available point to test, and $b = 1$, as our problem decreases by a constant factor of 1 in each subsequent call, thus, we can denote our approach as being defined by \begin{equation*}
	T(n) \leq \left\{
	\begin{array}{ll}
		c & \text{if } n \leq 1,\\
		PT(n-1)+f(n) & \text{if } n > 1,
	\end{array} 
\right.\end{equation*} 
and $f(n)=P\lfloor \frac{E^2}{4} \rfloor \implies \mathcal{O}(1)$. As shown above, we can then see that the time complexity of our algorithm is \large{$\mathcal{O}(P\textsuperscript{$n$})$}\normalsize.

\begin{thebibliography}{11}
\footnotesize
\bibitem{textbook}
Thomas H. Cormen, Charles E. Leiserson, Ronald Rivest, Clifford Stein  (2001) \emph{Introduction to Algorithms}, The MIT press, 2nd Edition
\bibitem{textbook2}
Jeff Erickson (2018) \emph{Algorithms}, 0th Edition (pre-publication draft)
\bibitem{textbook3}
David Saunders - saunders@udel.edu - \emph{CISC320 Algorithms - Recurrence Relations Master Theorem and Muster Theorem} - \url{https://www.eecis.udel.edu/~saunders/notes/recurrence-relations.pdf}
\end{thebibliography}



\section*{Team members}

\small
\begin{tabularx}{\linewidth}{ l c c }
\multicolumn{1}c{Name} & Student ID & Signature \\
\hline
João Soares & 2009113061 &   \\
\hline
José Ferreira & 2014192844 &  \\
\hline
Madalena Santos & 2016226726 & \\
\hline
\end{tabularx}

\end{document}